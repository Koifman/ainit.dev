export const config = { runtime: 'edge' };

function parseParams(rawUrl) {
  const q = rawUrl.indexOf('?');
  if (q === -1) return {};
  const qs = rawUrl.slice(q + 1).replace(/%3F/gi, '?').replace(/%3D/gi, '=').replace(/%26/gi, '&');
  const p = {};
  for (const pair of qs.split(/[?&]/)) { if (pair.startsWith('path=')) continue; const eq = pair.indexOf('='); if (eq !== -1) try { p[pair.slice(0, eq)] = decodeURIComponent(pair.slice(eq + 1)); } catch { p[pair.slice(0, eq)] = pair.slice(eq + 1); } }
  return p;
}

export default async function handler(req) {
  const url = new URL(req.url);
  const params = parseParams(req.url);
  const slugs = url.pathname.replace('/api/guardrails/', '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
  const catFilter = params.c || null;
  const formatParam = (params.o || '').toLowerCase();

  const formatMap = {
    agents: 'AGENTS.md', claude: 'CLAUDE.md', cursor: '.cursorrules',
    windsurf: '.windsurfrules', copilot: 'copilot-instructions.md', gemini: 'GEMINI.md',
  };
  const outputFilename = formatMap[formatParam] || 'AGENTS.md';

  if (!slugs.length) {
    return new Response('Usage: curl -L ainit.dev/api/guardrails/react,python\n\nSee https://ainit.dev/guardrails for available technologies.\n', { headers: { 'Content-Type': 'text/plain' } });
  }

  const base = new URL('/', url.origin);
  const index = await fetch(new URL('/gr/index.json', base)).then(r => r.json());
  const validTechs = new Set(index.technologies.map(t => t.slug));
  const bad = slugs.filter(s => !validTechs.has(s));

  if (bad.length) {
    const list = index.technologies.map(t => t.slug).sort().join(', ');
    return new Response(`Unknown technology(ies): ${bad.join(', ')}\n\nAvailable: ${list}\n`, { status: 404, headers: { 'Content-Type': 'text/plain' } });
  }

  // Determine active categories
  const validCats = new Set(index.categories.map(c => c.slug));
  let activeCats = index.categories.map(c => c.slug);
  if (catFilter) {
    activeCats = catFilter.split(',').filter(c => validCats.has(c));
  }

  // Fetch all needed files in parallel
  const catFetches = activeCats.map(slug =>
    fetch(new URL(`/gr/categories/${slug}.md`, base)).then(r => r.ok ? r.text() : '').catch(() => '')
  );
  const techFetches = slugs.map(slug =>
    fetch(new URL(`/gr/tech/${slug}.md`, base)).then(r => r.ok ? r.text() : '').catch(() => '')
  );
  const [catContents, techContents] = await Promise.all([
    Promise.all(catFetches),
    Promise.all(techFetches),
  ]);

  // Parse tech files into sections
  const techSections = slugs.map((slug, i) => ({
    slug,
    name: index.technologies.find(t => t.slug === slug)?.name || slug,
    sections: extractSections(techContents[i]),
  }));

  // Build output
  const curlParts = [];
  if (catFilter) curlParts.push(`c=${catFilter}`);
  curlParts.push(`o=${formatParam || 'agents'}`);
  let output = `# === ${outputFilename} ===\n`;
  if (outputFilename === 'AGENTS.md') output += `# AGENTS.md specification by https://agents.md\n`;
  output += `# Generated by ainit.dev/guardrails\n# Technologies: ${slugs.join(', ')}\n# curl -L ainit.dev/api/guardrails/${slugs.join(',')}?${curlParts.join('?')}\n\n`;

  activeCats.forEach((catSlug, i) => {
    const cat = index.categories.find(c => c.slug === catSlug);
    if (catContents[i]) {
      output += catContents[i] + '\n';
    }

    for (const tech of techSections) {
      const section = tech.sections[cat.name];
      if (section) {
        output += `\n## ${tech.name}\n${section}\n`;
      }
    }
    output += '\n';
  });

  return new Response(output.trim() + '\n', { headers: { 'Content-Type': 'text/plain; charset=utf-8' } });
}

function extractSections(markdown) {
  const sections = {};
  if (!markdown) return sections;
  const lines = markdown.split('\n');
  let current = null;
  let buf = [];

  for (const line of lines) {
    const match = line.match(/^##\s+(.+)$/);
    if (match) {
      if (current) sections[current] = buf.join('\n').trim();
      current = match[1].trim();
      buf = [];
    } else if (current) {
      buf.push(line);
    }
  }
  if (current) sections[current] = buf.join('\n').trim();
  return sections;
}
