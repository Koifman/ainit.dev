import { defineConfig } from 'vite';
import fs from 'fs';
import path from 'path';

// Parse query params splitting ONLY on ? (& is NOT a valid separator)
function parseParams(rawUrl) {
  const q = rawUrl.indexOf('?');
  if (q === -1) return {};
  const pairs = rawUrl.slice(q + 1).split('?');
  const p = {};
  for (const pair of pairs) { const eq = pair.indexOf('='); if (eq !== -1) try { p[pair.slice(0, eq)] = decodeURIComponent(pair.slice(eq + 1)); } catch { p[pair.slice(0, eq)] = pair.slice(eq + 1); } }
  return p;
}

function getPathname(rawUrl) {
  const q = rawUrl.indexOf('?');
  return q === -1 ? rawUrl : rawUrl.slice(0, q);
}

function apiDevPlugin() {
  return {
    name: 'api-dev',
    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        // --- Init API ---
        if (req.url.startsWith('/api/init')) {
          const params = parseParams(req.url);
          const techs = params.t || '';
          const guardrails = params.g || '';
          const catFilter = params.c || '';
          const format = (params.o || 'agents').toLowerCase();
          const shell = (params.s || 'sh').toLowerCase();

          const initFormatMap = {
            cursor:   { ignore: '.cursorignore',  rules: '.cursorrules',             ignoreSlug: 'cursorignore', rulesSlug: 'cursor' },
            claude:   { ignore: '.claudeignore',  rules: 'CLAUDE.md',               ignoreSlug: 'claudeignore', rulesSlug: 'claude' },
            agents:   { ignore: '.aiignore',      rules: 'AGENTS.md',               ignoreSlug: 'aiignore',     rulesSlug: 'agents' },
            windsurf: { ignore: '.codeiumignore', rules: '.windsurfrules',          ignoreSlug: 'codeiumignore', rulesSlug: 'windsurf' },
            copilot:  { ignore: '.aiexclude',     rules: '.github/copilot-instructions.md', ignoreSlug: 'aiexclude',    rulesSlug: 'copilot' },
            gemini:   { ignore: '.geminiignore',  rules: 'GEMINI.md',               ignoreSlug: 'geminiignore', rulesSlug: 'gemini' },
          };
          const fmt = initFormatMap[format] || initFormatMap.agents;

          res.setHeader('Content-Type', 'text/plain; charset=utf-8');

          if (!techs && !guardrails) {
            res.end(
              'Usage: curl -sL "ainit.dev/api/init?t=react,node?g=react,node?o=cursor" | sh\n\n' +
              'Parameters:\n  t= .aiignore templates\n  g= guardrails technologies\n  c= guardrails categories (optional)\n  o= tool: agents, cursor, claude, windsurf, copilot, gemini\n  s= shell: sh (default), ps (PowerShell)\n\n' +
              'See https://ainit.dev for available templates and technologies.\n'
            );
            return;
          }

          // Build ignore content
          let ignoreContent = '';
          if (techs) {
            const templatesDir = path.resolve('public/templates');
            const tIndex = JSON.parse(fs.readFileSync(path.join(templatesDir, 'index.json'), 'utf-8'));
            const tValid = new Set(tIndex.map(t => t.slug));
            const tSlugs = techs.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
            const tBad = tSlugs.filter(s => !tValid.has(s));
            if (tBad.length) {
              res.statusCode = 404;
              res.end(`Unknown template(s): ${tBad.join(', ')}\n\nAvailable: ${tIndex.map(t => t.slug).sort().join(', ')}\n`);
              return;
            }
            const parts = tSlugs.map(s => fs.readFileSync(path.join(templatesDir, `${s}.txt`), 'utf-8'));
            const header = `# === ${fmt.ignore} ===\n# Templates: ${tSlugs.join(', ')}\n# curl -L ainit.dev/api/${tSlugs.join(',')}?o=${fmt.ignoreSlug}\n`;
            ignoreContent = header + '\n' + parts.join('\n');
          }

          // Build guardrails content
          let rulesContent = '';
          if (guardrails) {
            const grDir = path.resolve('public/guardrails');
            const gIndex = JSON.parse(fs.readFileSync(path.join(grDir, 'index.json'), 'utf-8'));
            const gValid = new Set(gIndex.technologies.map(t => t.slug));
            const gSlugs = guardrails.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
            const gBad = gSlugs.filter(s => !gValid.has(s));
            if (gBad.length) {
              res.statusCode = 404;
              res.end(`Unknown technology(ies): ${gBad.join(', ')}\n\nAvailable: ${gIndex.technologies.map(t => t.slug).sort().join(', ')}\n`);
              return;
            }
            const validCats = new Set(gIndex.categories.map(c => c.slug));
            let activeCats = gIndex.categories.map(c => c.slug);
            if (catFilter) activeCats = catFilter.split(',').filter(c => validCats.has(c));

            let output = `# === ${fmt.rules} ===\n# Generated by ainit.dev/guardrails\n# Technologies: ${gSlugs.join(', ')}\n# curl -L ainit.dev/api/guardrails/${gSlugs.join(',')}?o=${fmt.rulesSlug}\n\n`;
            for (const catSlug of activeCats) {
              const cat = gIndex.categories.find(c => c.slug === catSlug);
              const catFile = path.join(grDir, 'categories', `${catSlug}.md`);
              if (fs.existsSync(catFile)) output += fs.readFileSync(catFile, 'utf-8') + '\n';
              for (const techSlug of gSlugs) {
                const techFile = path.join(grDir, 'tech', `${techSlug}.md`);
                if (fs.existsSync(techFile)) {
                  const section = extractSection(fs.readFileSync(techFile, 'utf-8'), cat.name);
                  if (section) {
                    const tech = gIndex.technologies.find(t => t.slug === techSlug);
                    output += `\n## ${tech.name}\n${section}\n`;
                  }
                }
              }
              output += '\n';
            }
            rulesContent = output.trim() + '\n';
          }

          // Generate script
          if (shell === 'ps') {
            let script = '';
            if (ignoreContent) {
              script += `@'\n${ignoreContent}`;
              if (!ignoreContent.endsWith('\n')) script += '\n';
              script += `'@ | Set-Content -Path '${fmt.ignore}' -Encoding UTF8\n`;
              script += `Write-Host "Created ${fmt.ignore}"\n`;
            }
            if (rulesContent) {
              const dir = fmt.rules.includes('/') ? fmt.rules.slice(0, fmt.rules.lastIndexOf('/')) : '';
              if (dir) script += `New-Item -ItemType Directory -Force -Path '${dir}' | Out-Null\n`;
              script += `@'\n${rulesContent}`;
              if (!rulesContent.endsWith('\n')) script += '\n';
              script += `'@ | Set-Content -Path '${fmt.rules}' -Encoding UTF8\n`;
              script += `Write-Host "Created ${fmt.rules}"\n`;
            }
            res.end(script);
          } else {
            let script = '#!/bin/sh\n';
            if (ignoreContent) {
              script += `cat > '${fmt.ignore}' << 'AINIT_IGNORE_EOF'\n`;
              script += ignoreContent;
              if (!ignoreContent.endsWith('\n')) script += '\n';
              script += 'AINIT_IGNORE_EOF\n';
              script += `echo "Created ${fmt.ignore}"\n`;
            }
            if (rulesContent) {
              const dir = fmt.rules.includes('/') ? fmt.rules.slice(0, fmt.rules.lastIndexOf('/')) : '';
              if (dir) script += `mkdir -p '${dir}'\n`;
              script += `cat > '${fmt.rules}' << 'AINIT_RULES_EOF'\n`;
              script += rulesContent;
              if (!rulesContent.endsWith('\n')) script += '\n';
              script += 'AINIT_RULES_EOF\n';
              script += `echo "Created ${fmt.rules}"\n`;
            }
            res.end(script);
          }
          return;
        }

        // --- Guardrails API ---
        if (req.url.startsWith('/api/guardrails/')) {
          const grParams = parseParams(req.url);
          const slugs = getPathname(req.url).replace('/api/guardrails/', '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
          const catFilter = grParams.c || null;
          const formatParam = (grParams.o || '').toLowerCase();

          const grFormatMap = {
            agents: 'AGENTS.md', claude: 'CLAUDE.md', cursor: '.cursorrules',
            windsurf: '.windsurfrules', copilot: 'copilot-instructions.md', gemini: 'GEMINI.md',
          };
          const grOutputFilename = grFormatMap[formatParam] || 'AGENTS.md';

          const grDir = path.resolve('public/guardrails');
          const index = JSON.parse(fs.readFileSync(path.join(grDir, 'index.json'), 'utf-8'));
          const validTechs = new Set(index.technologies.map(t => t.slug));
          const validCats = new Set(index.categories.map(c => c.slug));

          res.setHeader('Content-Type', 'text/plain; charset=utf-8');

          if (!slugs.length) {
            res.end('Usage: curl -L ainit.dev/api/guardrails/react,python\n\nSee https://ainit.dev/guardrails for available technologies.\n');
            return;
          }

          const bad = slugs.filter(s => !validTechs.has(s));
          if (bad.length) {
            res.statusCode = 404;
            res.end(`Unknown technology(ies): ${bad.join(', ')}\n\nAvailable: ${index.technologies.map(t => t.slug).sort().join(', ')}\n`);
            return;
          }

          // Determine active categories
          let activeCats = index.categories.map(c => c.slug);
          if (catFilter) {
            activeCats = catFilter.split(',').filter(c => validCats.has(c));
          }

          // Build output — mirror the original query string with ? separators
          const grRawQs = req.url.split('?').slice(1).join('?') || `o=agents`;
          let output = `# === ${grOutputFilename} ===\n# Generated by ainit.dev/guardrails\n# Technologies: ${slugs.join(', ')}\n# curl -L ainit.dev/api/guardrails/${slugs.join(',')}?${grRawQs}\n\n`;

          for (const catSlug of activeCats) {
            const cat = index.categories.find(c => c.slug === catSlug);
            const catFile = path.join(grDir, 'categories', `${catSlug}.md`);
            if (fs.existsSync(catFile)) {
              output += fs.readFileSync(catFile, 'utf-8') + '\n';
            }

            // Tech-specific sections
            for (const techSlug of slugs) {
              const techFile = path.join(grDir, 'tech', `${techSlug}.md`);
              if (fs.existsSync(techFile)) {
                const techContent = fs.readFileSync(techFile, 'utf-8');
                const section = extractSection(techContent, cat.name);
                if (section) {
                  const tech = index.technologies.find(t => t.slug === techSlug);
                  output += `\n## ${tech.name}\n${section}\n`;
                }
              }
            }
            output += '\n';
          }

          res.end(output.trim() + '\n');
          return;
        }

        // --- Aiignore API ---
        if (!req.url.startsWith('/api/')) return next();

        const aiParams = parseParams(req.url);
        const slugs = getPathname(req.url).replace('/api/', '').split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
        const aiFormatParam = (aiParams.o || '').toLowerCase();

        const aiFormatMap = {
          aiignore: '.aiignore', cursorignore: '.cursorignore', aiexclude: '.aiexclude',
          codeiumignore: '.codeiumignore', geminiignore: '.geminiignore', claudeignore: '.claudeignore',
        };
        const aiOutputFilename = aiFormatMap[aiFormatParam] || '.aiignore';

        const templatesDir = path.resolve('public/templates');
        const index = JSON.parse(fs.readFileSync(path.join(templatesDir, 'index.json'), 'utf-8'));
        const valid = new Set(index.map(t => t.slug));

        res.setHeader('Content-Type', 'text/plain; charset=utf-8');

        if (!slugs.length) {
          res.end('Usage: curl -L ainit.dev/api/react,node,typescript\n\nSee https://ainit.dev for available templates.\n');
          return;
        }

        const bad = slugs.filter(s => !valid.has(s));
        if (bad.length) {
          res.statusCode = 404;
          res.end(`Unknown template(s): ${bad.join(', ')}\n\nAvailable: ${index.map(t => t.slug).sort().join(', ')}\n`);
          return;
        }

        const parts = slugs.map(s => fs.readFileSync(path.join(templatesDir, `${s}.txt`), 'utf-8'));
        const aiRawQs = req.url.split('?').slice(1).join('?') || `o=aiignore`;
        const header = `# === ${aiOutputFilename} ===\n# Templates: ${slugs.join(', ')}\n# curl -L ainit.dev/api/${slugs.join(',')}?${aiRawQs}\n`;
        res.end(header + '\n' + parts.join('\n'));
      });

      // SPA fallback — serve index.html for client-side routes
      server.middlewares.use((req, res, next) => {
        if (req.url === '/guardrails' || req.url.startsWith('/guardrails?') ||
            req.url === '/how-to-use' || req.url.startsWith('/how-to-use?')) {
          req.url = '/index.html';
        }
        next();
      });
    },
  };
}

function extractSection(markdown, categoryName) {
  const lines = markdown.split('\n');
  let capturing = false;
  let buf = [];

  for (const line of lines) {
    const match = line.match(/^##\s+(.+)$/);
    if (match) {
      if (capturing) break;
      if (match[1].trim() === categoryName) capturing = true;
    } else if (capturing) {
      buf.push(line);
    }
  }
  const result = buf.join('\n').trim();
  return result || null;
}

export default defineConfig({
  plugins: [apiDevPlugin()],
  publicDir: 'public',
  build: {
    outDir: 'dist',
  },
});
